#!/usr/bin/env python

import numpy as np
from supervillain.h5 import H5able
from supervillain.configurations import Configurations

import logging
logger = logging.getLogger(__name__)

class Villain(H5able):
    r'''
    'The' Villain action is just the straightforward

    .. math::
       \begin{align}
       Z[J] &= \sum\hspace{-1.33em}\int D\phi\; Dn\; e^{-S_J[\phi, n]}
       &
       S_J[\phi, n] &= \frac{\kappa}{2} \sum_{\ell} (d\phi - 2\pi n)_\ell^2 + i \sum_p J_p (dn)_p
       \end{align}

    with $\phi$ a real-valued 0-form that lives on sites, $n$ an integer-valued one form that lives on links $l$, and $J$ a two-form that lives on plaquettes $p$.

    In this formulation, if $J$ is real and nonzero we expect a sign problem because the action is complex.  However, we can think of $J$ as an external source, take functional derivatives to get observables, and then set $J$ to zero so that we only need sample according to the first term.

    Parameters
    ----------
    lattice: supervillain.lattice.Lattice2D
        The lattice on which $\phi$ and $n$ live.
    kappa: float
        The $\kappa$ in the overall coefficient.
    '''

    def __init__(self, lattice, kappa):

        self.Lattice = lattice
        self.kappa = kappa

    def __str__(self):
        return f'Villain({self.Lattice}, κ={self.kappa})'

    def __call__(self, phi, n, **kwargs):
        r'''
        Parameters
        ----------
        phi: np.ndarray
            A real-valued 0-form.
        n: np.ndarray
            An integer-valued 1-form.

        Returns
        -------
        float
            $S_0[\phi, n]$
        '''
        return self.kappa / 2 * np.sum((self.Lattice.d(0, phi) - 2*np.pi*n)**2)

    def configurations(self, count):
        r'''
        Parameters
        ----------
        count: int

        Returns
        -------
        dict
            A dictionary of zeroed arrays at keys ``phi`` and ``n``, holding ``count`` 0- and 1-forms respectively.
        '''
        return Configurations({
            'phi': self.Lattice.form(0, count),
            'n':   self.Lattice.form(1, count, dtype=int),
            })

    def gauge_transform(self, configuration, k):
        r'''
        The Villain formulation has the gauge symmetry 

        .. math::
           \phi &\rightarrow\; \phi + 2\pi k
           \\
           n &\rightarrow\; n + dk

        with the gauge-invariant combination $(d\phi - 2\pi n)$.

        Parameters
        ----------
        configuration: dict
            A dictionary with the fields.
        k: np.array
            The gauge transformation parameter $k$ which must be of integer dtype.

        Returns
        -------
        dict:
            A dictionary with the fields transformed by $k$.
        '''

        if not issubclass(k.dtype.type, np.integer):
            raise ValueError('The gauge transformation is generated by integer k; it must be of integer dtype.')

        return {
            'phi': configuration['phi'] + 2*np.pi*k,
            'n':   configuration['n']   + self.Lattice.d(0, k),
        }

class Worldline(H5able):
    r'''
    The dual (worldline) action is

    .. math::
       \begin{align}
       Z[J] &= \sum Dm\; e^{-S_J[m]} \left[\delta m = 0\right]
       &
       S_J[m] &= \frac{1}{2\kappa} \sum_\ell \left(m - \frac{\delta J}{2\pi}\right)_\ell^2 + \frac{|\ell|}{2} \ln (2\pi \kappa) - |x| \ln 2\pi
       \end{align}

    In other words, it is a sum over all configurations where $\delta m$ vanishes on every site.

    This formulation has no obvious sign problem when $J\neq 0 $, but maintaining the constraint $\delta m = 0$ requires a nontrivial algorithm.

    Parameters
    ----------
    lattice: supervillain.Lattice2D
        The lattice on which $m$ lives.
    kappa: float
        The $\kappa$ in the overall coefficient.


    '''

    def __init__(self, lattice, kappa):

        self.Lattice = lattice
        self.kappa = kappa
        self._constant_offset = self.Lattice.links / 2 * np.log(2*np.pi*kappa) - self.Lattice.sites * np.log(2*np.pi)

    def __str__(self):
        return f'Worldline({self.Lattice}, κ={self.kappa})'

    def valid(self, m):
        r'''
        Returns true if the constraint $[\delta m = 0]$ is satisfied everywhere and false otherwise.
        '''

        return (self.Lattice.delta(1, m) == 0).all()

    def __call__(self, m, **kwargs):
        r'''
        Parameters
        ----------
        m: np.ndarray
            An integer-valued 1-form.

        Returns
        -------
        float:
            $S_0[m]$

        Raises
        ------
        ValueError
            If $m$ does not satisfy the constraint.
        '''

        if not self.valid(m):
            raise ValueError(f'The one-form m does not satisfy the constraint δm = 0 everywhere.')
        return 0.5 / self.kappa * np.sum(m**2) + self._constant_offset

    def configurations(self, count):
        r'''
        Parameters
        ----------
        count: int
            How many configurations to return.

        Returns
        -------
        dict
            A dictionary of zeroed arrays at key ``m`` holding ``count`` 1-forms.
        '''

        return Configurations({
            'm': self.Lattice.form(1, count, dtype=int),
            })
    
    def count_loops(self, cfg):
        cfgabs = np.abs(cfg)
        #Takes the absolute value of a configuration's links to determine where a worm perturbation is
        #This must be applied to a worm on a zero background field, (or just subtract out the background field from before the worm)
        #Here I am checking each site for whether it lies on the worm (has an adjacent non-zero link),
        #and if so then give it an integer value. This is basically just a unique identifier, so the integer value 
        #increments each time
        q = 1
        ledger = self.Lattice.form(0)
        for i in range(self.Lattice.dims[0]):
            for j in range(self.Lattice.dims[1]):
                if (np.array([cfgabs[0,i,j],cfgabs[1,i,j],cfgabs[0,i-1,j],cfgabs[1,i,j-1]])>0).any():
                    ledger[i,j]=q
                    q+=1

        oldledger = np.empty_like(ledger)
        while (ledger != oldledger).any():  #As long as we are not in a steady state
            oldledger = ledger.copy()
            for i in range(ledger.shape[0]):
                for j in range(ledger.shape[1]):
                    if ledger[i,j] != 0:
                        for adj in [1,2,3,4]:   #Sift through each non-zero point in the ledger and its 
                            #adjacent links
                            #[1,2,3,4] -> [East,N,W,S]
                            if adj == 1:
                                test_link = cfgabs[0,i,j]
                                if test_link > 0:
                                    #Here we check if the worm passes through a neighboring link, and if so we take
                                    #the maximum of the two points connected by that link and adopt that for both
                                    ledger[i,j] = max(ledger[i,j],ledger[self.Lattice.mod([i+1,j])[0],self.Lattice.mod([i+1,j])[1]])
                                    ledger[self.Lattice.mod([i+1,j])[0],self.Lattice.mod([i+1,j])[1]] = ledger[i,j]
                            if adj == 2:
                                test_link = cfgabs[1,i,j]
                                if test_link > 0:
                                    ledger[i,j] = max(ledger[i,j],ledger[self.Lattice.mod([i,j+1])[0],self.Lattice.mod([i,j+1])[1]])
                                    ledger[self.Lattice.mod([i,j+1])[0],self.Lattice.mod([i,j+1])[1]] = ledger[i,j]
                            if adj == 3:
                                test_link = cfgabs[0,i-1,j]
                                if test_link > 0:
                                    ledger[i,j] = max(ledger[i,j],ledger[self.Lattice.mod([i-1,j])[0],self.Lattice.mod([i-1,j])[1]])
                                    ledger[self.Lattice.mod([i-1,j])[0],self.Lattice.mod([i-1,j])[1]] = ledger[i,j]
                            if adj == 4:
                                test_link = cfgabs[1,i,j-1]
                                if test_link > 0:
                                    ledger[i,j] = max(ledger[i,j],ledger[self.Lattice.mod([i,j-1])[0],self.Lattice.mod([i,j-1])[1]])
                                    ledger[self.Lattice.mod([i,j-1])[0],self.Lattice.mod([i,j-1])[1]] = ledger[i,j]
        #Once the process reaches a steady state, ie. the maximums in all connected loops have proliferated
        #we can just count the number of unique maximums that we obtain (other than 0)
        return np.sum(np.unique(ledger) > 0)
